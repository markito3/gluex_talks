\documentclass[12pt]{article}

\usepackage{graphicx}

% global parameters
\textwidth=6.5in
\oddsidemargin=0in % use built-in offset of 1 inch for left margin
\evensidemargin=0in % ditto for even pages
\textheight=9in
\topmargin=0in
\headheight=0in % no headers in this document
\headsep=0in

\title{A Version Management System for GlueX}
\author{Mark M.\ Ito \\ \medskip Jefferson Lab}
\date{October 9, 2015}

\begin{document}

\maketitle

\section{Introduction}
There are three fundamental areas of concern that make up all software
systems. They are:

\begin{enumerate}
\item a directory structure
\item a build system
\item a version management system
\end{enumerate}

They are all related, aspects of one affects aspects of each of the others.

\section{The Packages}

\begin{enumerate}
\item build\_scripts: scripts to manage building and the shell environment
\item Xerces-C: for reading XML files
\item CERNLIB: to support GEANT 3 simulations
\item GEANT4: simulation engine
\item ROOT: general purpose HENP toolkit
\item EVIO: CODA format data handling library
\item CCDB: Calibration Constants Database
\item JANA: event-based analysis framework
\item HDDS: detector geometry specification library 
\item sim-recon: simulation and reconstruction for GlueX
\end{enumerate}

\begin{itemize}
\item multiple versions (releases) of each of these
\item more that one version of a package built
\item packages depend on one or several others
\end{itemize}

\section{The Directory Structure}\label{section:directory}

VMS looks for the name of this directory in the environment variable {\tt GLUEX\_TOP}.

\begin{figure}
\begin{verbatim}
                    gluex_top
                    |-- build_scripts
                    |-- cernlib
                    |   `-- 2005
                    |-- evio
                    |   |-- evio-4.2
                    |   `-- evio-4.3.1
                    |-- hdds
                    |   |-- hdds-3.1
                    |   `-- hdds-3.2
                    |-- jana
                    |   |-- jana_0.7.2
                    |   `-- jana_0.7.3
                    |-- root
                    |   |-- root_5.34.04
                    |   `-- root_5.34.26
                    |-- sim-recon
                    |   |-- sim-recon-1.2.0
                    |   `-- sim-recon-1.3.0
                    `-- xerces-c
                        |-- xerces-c-3.1.1
                        `-- xerces-c-3.1.2
\end{verbatim}
\caption{The directory structure.}\label{fig:directory-tree}
\end{figure}

\section{Scripts to Implement the VMS: \\ the {\tt BUILD\_SCRIPTS} Directory}

All scripts and makefiles to support VMS are found the in the {\tt
  build\_scripts} directory. At JLab, the full path is
$${\tt /group/halld/Software/build\_scripts}.$$
The directory can also cloned from the Git repository at GitHub. The URL is
$${\tt https://github.com/jeffersonlab/build\_scripts}.$$
Many of the scripts and makefiles require the environment variable {\tt BUILD\_SCRIPTS} to be defined.

% got to here %

\section{Setting Up the Shell Environment}

* Environment setting needed for building and using
* Both Bourne shell and C shell supported

\subsection{Low-Level Environment Set-Up: {\tt gluex\_env.(c)sh}}
\label{section:low-level-environment-setting}

* The {\tt gluex\_env.(c)sh} script will define all environment variables
* Input: home directories of each package

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\bf Package & \bf Home Directory Variable \\
\hline Xerces-C & {\tt XERCESCROOT} \\
CERNLIB & {\tt CERN} \\
Geant4 & {\tt GEANT4\_HOME} \\
ROOT & {\tt ROOTSYS} \\
EVIO & {\tt EVIOROOT} \\
CCDB & {\tt CCDB\_HOME} \\
JANA & {\tt JANA\_HOME} \\
HDDS & {\tt HDDS\_HOME} \\
sim-recon & {\tt HALLD\_HOME} \\
\hline
\end{tabular}
\end{center}
\caption{Packages and their home directories.}\label{table:home-directories}
\end{table}

* {\tt gluex\_env.(c)sh} takes care of all the other variables.
** For example, {\tt XERCES\_INCLUDE} is defined as {\tt \$XERCESCROOT/include}.** Directories are added to the {\tt PATH}, {\tt LD\_LIBRARY\_PATH}, and {\tt PYTHONPATH}

\subsubsection{Pre-Defined Home Variables and Defaults}

* If defined in advance, key variables will be respected.
* If not default provided.
** {\tt GLUEX\_TOP}, default =  {\tt /usr/local/gluex}
** {\tt BUILD\_SCRIPTS}, default = {\tt \$GLUEX\_TOP/build\_scripts}
** Home directories, default = {\tt \$GLUEX\_TOP/<package>/prod}
* See example below

\subsubsection{Consistency Checking}

The final step in {\tt gluex\_env.(c)sh} is to check the resulting
environment for consistency using the prerequisites system. Each home
directory is checked for a prerequisites version file. Those files
list versions of prerequisite packages used at build time. The
build-time version are checked against the versions used in the
just-set-up environment and warnings are printed when mismatches are
detected. See Section~\ref{section:prerequisites-system} for the
details.

\subsubsection{Cleaning the Environment: {\tt gluex\_env\_clean.(c)sh}}

Since {\tt gluex\_env.(c)sh} is sensitive to definitions hanging
around in the environment, there is a script provided that will undo
all GlueX-related definitions: \break {\tt gluex\_env\_clean.(c)sh}. Sourcing
it will eliminate unintended consequences from previously made
definitions. For the path variables the script only removes the
GlueX-related elements leaving all others present in the path.

\subsection{High-Level Environment Set-Up}

\subsubsection{Custom Scripts}\label{section:custom-scripts}

The most common reason to have a custom script is when you want to use
a package that is outside the standard directory structure. Since {\tt
  gluex\_env.(c)sh} will respect a pre-defined value of any of the
home directories, this can be done without making a private version of
{\tt gluex\_env.(c)sh}. See Fig.~\ref{figure:custom-script} for an
example. Here a version of sim-recon built in a non-standard location
(the user's home directory) will be used in the resulting environment.

\begin{figure}
\begin{verbatim}
          export GLUEX_TOP=/home/gluex/gluex_top
          export BUILD_SCRIPTS=$GLUEX_TOP/build_scripts
          export HALLD_HOME=/home/username/sim-recon
          source $BUILD_SCRIPTS/gluex_env.sh
\end{verbatim}
\caption{Example of a custom set-up script. The build of sim-recon in
  the user's home directory will be used. All other packages be set up
  to use with their default builds under {\tt
    /home/gluex/gluex\_top}. Note that {\tt GLUEX\_TOP} and {\tt
  BUILD\_SCRIPTS} are defined explicitly rather than letting them
default.}\label{figure:custom-script}
\end{figure}

\subsubsection{Using the Versioning System}/label{section:env-use-versioning}

Another way to get a non-default environment is to use the versioning
system to set home directory locations which in turn are respected by
{\tt gluex\_env.(c)sh}. The versioning system is described in detail
in Section~\ref{section:versioning}, but an example set-up script is
shown in Fig.~\ref{figure:version-script}. In this example, package version
information is contained in the XML file {\tt my\_versions.xml} in the
user's home area. An example version file is shown in Fig.~\ref{figure:version-xml}. Alternate combinations of package versions can be tried by making alternate versions of the version file.

\begin{figure}
\begin{verbatim}
        export GLUEX_TOP=/home/gluex/gluex_top
        export BUILD_SCRIPTS=$GLUEX_TOP/build_scripts
        source $BUILD_SCRIPTS/gluex_env_version.sh \
            /home/username/my_versions.xml
\end{verbatim}
\caption{Example of a set-up script driven by a private version
  file. See Section~\ref{section:versioning} for the format of the
  file.}\label{figure:version-script}
\end{figure}

\subsubsection{Default Environment at JLab}

At JLab there is script that packages the steps shown in Fig.~\ref{figure:version-script}, with the appropriate values of {\tt GLUEX\_TOP} and {\tt BUILD\_SCRIPTS}. It uses the latest version of {\tt version.xml}. It can also be used as an example for using a custom version of {\tt version.xml}. To use it, for bash:
\begin{verbatim}
        source /group/halld/Software/build_scripts/gluex_env_jlab.sh
\end{verbatim}
and for tcsh:
\begin{verbatim}
        source /group/halld/Software/build_scripts/gluex_env_jlab.csh
\end{verbatim}

\section{The Build System}

Each of the packages have their own native build system and each build
system has its own set of details that have to be understood. In
addition, the technology used to do the build varies from system to
system. It may be make, imake, cmake, SCons, or something else. The
VMS system makes a choice of build options for each package so that
the user need not master these details.

\subsection{The Makefiles}

The VMS build system is implemented in GNU Make. These makefiles
invoke the native package-specific build system. There is a ``package
makefile'' for each package ({\it e.~g.}, {\tt Makefile\_jana,
  Makefile\_sim-recon}). Invoking make with a package makefile will
build that package with the home directory placed in the current
working directory. Thus, the package makefiles have no knowledge of
the directory structure within which they are used; they just build
locally.

\subsubsection{The Top-Level: {\tt Makefile\_all}}

Complete builds are orchestrated by {\tt Makefile\_all}. The highest-level
targets of Makefile\_all, shown with their dependencies are:

\begin{verbatim}
all: env xerces_build cernlib_build cernlib_debug_build root_build \
     clhep_build geant4_build gsl_build evio_build ccdb_build \
     jana_build hdds_build sim-recon_build

gluex: env xerces_build cernlib_build root_build clhep_build \
       evio_build ccdb_build jana_build hdds_build \
       sim-recon_build

gluex_jlab: env xerces_build root_build clhep_build evio_build \
            ccdb_build jana_build hdds_build sim-recon_build
\end{verbatim}

The {\tt all} target builds every package that {\tt Makefile\_all} knows
about. The {\tt gluex} target builds only the packages necessary for
using GlueX software. The {\tt gluex\_jlab} target is the same as {\tt gluex}
except that it does not include {\tt cernlib\_build} (useful for JLab public
builds where we use the community-built versions of CERNLIB).

{{\tt Makefile\_all}} should always be invoked from the {\tt
  \$GLUEX\_TOP} directory.

\subsubsection{Individual Package Targets}

Each of the individual package targets ({\it e.~g.}, {\tt evio\_build}
and {\tt hdds\_build}) use the corresponding package
makefile. Directories are created and the package makes are executed
in way that gives the directory structure described in
Section~\ref{section:directory}. To do this, the package container
directory is created if it does not exist and the requested package
makefile is invoked from within the package container directory.

Of course, each individual package build target can be invoked
directly. More on this in Section~\ref{section:adding-packages}

\subsubsection{Special Package Target}

The target {\tt cernlib\_debug} is non-standard. If this target is
invoked, it well create a separate container directory {\tt
  cernlib\_debug} for the debug versions. Also it does not have its
own package makefile, rather on 64-bit machines, it invokes {\tt
  Makefile\_cernlib\_Vogt} with command line options that cause
appropriate debug compiler flags to be used.

To use the resulting debug version of CERNLIB, the {\tt CERN} variable
must be set to point to the {\tt cernlib\_debug} directory, either explicitly as an environment variable (as described in Section~\ref{section:custom-scripts} or by using the {\tt home} attribute in the {\tt package} element of a version file (as described in Section~\ref{section:versioning}.

\subsection{The Package Makefiles}\label{section:package-makefiles}

Each of the package makefiles is sensitive to environment variables
that control which version of the package to build. The makefiles
themselves take care of obtaining the source code.

Each packages respects a version-specifying environment variable. Here
is an example of how they might be set in the C-shell:

\begin{verbatim}
setenv JANA_VERSION 0.7.2
setenv SIM_RECON_VERSION 1.2.0
setenv HDDS_VERSION 3.2
setenv CERNLIB_VERSION 2005
setenv XERCES_C_VERSION 3.1.1
setenv CLHEP_VERSION 2.0.4.5
setenv ROOT_VERSION 5.34.26
setenv CCDB_VERSION 1.05
setenv EVIO_VERSION 4.3.1
\end{verbatim}

In each case there is standard system for distributing tarballs marked
with the version name. Each package has different conventions, but the
package makefiles have that knowledge of the appropriate convention
coded in. Also, the name of home directory created depends on the name
that appears in the tarball (with exceptions as mentioned in
Section~\ref{section:directory-tags}. Note that the version variable
can be set on the make command line as well.

Some packages can be checked out from a Subversion repository. In
these cases, the version variable is ignored. JANA, HDDS, and
sim-recon have this support. So for example:

\begin{verbatim}
setenv HDDS_URL https://halldsvn.jlab.org/repos/trunk/hdds
\end{verbatim}

will cause the HDDS makefile to check out the trunk version. The names
of the variables for JANA and sim-recon are {\tt JANA\_URL} and {\tt
  SIM\_RECON\_URL} respectively.

\subsubsection{Package-Specific Variable for {\tt Makefile\_sim-recon}}

For the sim-recon package, there is a variable, {\tt
  SIM\_RECON\_SCONS\_OPTIONS} that can be defined, either in the shell
environment on on the make command line, that will supply optional
arguments to the {\tt scons} command invoked by make. For example,
\begin{verbatim}
        make -f $BUILD_SCRIPTS/Makefile_sim-recon \
            SIM_RECON_SCONS_OPTIONS='SHOWBUILDS=1'
\end{verbatim}
will cause SCons to show the compiler commands explicitly.

\subsection{Adding New Package Builds to an Existing Tree}\label{section:adding-packages}

There are two ways:

\subsubsection{Use the Top-Level {\tt Makefile\_all}}

After setting the desired values of the version environment variables
and/or the URL environment variables (see
Section~\ref{section:package-makefiles} you can invoke {\tt
  Makefile\_all} with the target(s) needed or with a high-level target
like {\tt gluex},
\begin{verbatim}
         cd $GLUEX_TOP
         make -f $BUILD_SCRIPTS/Makefile_all gluex
\end{verbatim}
If some of the versions of individual packages requested already
exist, then make will do the usual thing: try to remake them and find
that there is nothing to do.

\subsubsection{Use Individual Package Makefiles}

Since the individual package makefiles build in the local directory,
they can be used directly by going to the appropriate container
directory. For example,
\begin{verbatim}
cd $GLUEX_TOP/sim-recon
make -f $BUILD_SCRIPTS/Makefile_sim-recon SIM_RECON_VERSION=1.4.0
\end{verbatim}
Note that in this example the version is specified on the make command
line rather than through an environment variable. That is not
necessary; it is an option supported by make and defining {\tt
  SIM\_RECON\_VERSION} in the environment would work as well. Also
note that doing the build in the sim-recon container directory is not
necessary for the build to succeed; any directory will work. In this
example however we are adding to an existing standard directory
structure so we {\tt cd} to the standard directory.

\section{The Versioning System}\label{section:versioning}

\subsection{Version File Format: an XML}

The versioning system uses an XML-formatted version file to specify
both package version information and package home directory definition
in the shell environment. An example file is shown in
Fig.~\ref{figure:version-xml}.

\begin{figure}
\begin{verbatim}
  <gversions>
  <package name="jana" version="0.7.3"/>
  <package name="sim-recon" version="1.4.0"/>
  <package name="hdds" version="3.3"/>
  <package name="cernlib" version="2005" word_length="64-bit"/>
  <package name="xerces-c" version="3.1.1"/>
  <package name="clhep" version="2.0.4.5"/>
  <package name="root" version="5.34.26"/>
  <package name="ccdb" version="1.05"/>
  <package name="evio" version="4.3.1"/>
  </gversions>
\end{verbatim}
\caption{An example version file. {\tt version\_1.7.xml} is shown.}\label{figure:version-xml}
\end{figure}

There is only one type of element, the {\tt package}. Attributes are:

\begin{description}
\item{\bf name}: The name of the software package.
\item{\bf version}: The version number of the package.
\item{\bf url}: A URL to be used to checkout (Subversion) or clone
  (Git) the code. The URL should point to an appropriate repository.
\item{\bf branch}: When using a Git repository, the branch to be
  checked out.
\item{\bf dirtag}: A string (directory tag) to be appended to the
  standard directory name of the package when it is built.
\end{description}

\subsection{Setting Up the Environment with a Version File}

As we saw in Section~\ref{section:low-level-environment-setting},
environment setting via {\tt gluex\_env.(c)sh} is sensitive to the
definition of the package home variables. In
Section~\ref{section:package-makefiles}, we saw that the package
makefiles are sensitive to either the version-defining environment
variables or the URL-defining environment variables, using them to choose the
version of code to build. The version file can be used to define both
classes of variables. In this way it can be used to both build a
consistent set of packages and to set-up the environment to use the
build. Executing
\begin{verbatim}
           $BUILD_SCRIPTS/version.pl version_1.7.xml
\end{verbatim}
where for the purposes of this example {\tt version\_1.7.xml} is the
file shown in Fig.~\ref{figure:version-xml} and {\tt GLUEX\_TOP} is
{\tt /home/gluex/gluex\_top}, creates the output shown in
Fig.~\ref{figure:version-pl-output}.
\begin{figure}
\small
\begin{verbatim}
setenv JANA_VERSION 0.7.3;
setenv JANA_HOME \
    /home/gluex/gluex_top/jana/jana_0.7.3/Linux_RHEL7-x86_64-gcc4.8.3;
setenv SIM_RECON_VERSION 1.4.0;
setenv HALLD_HOME /home/gluex/gluex_top/sim-recon/sim-recon-1.4.0;
setenv HDDS_VERSION 3.3;
setenv HDDS_HOME /home/gluex/gluex_top/hdds/hdds-3.3;
setenv CERNLIB_VERSION 2005;
setenv CERN /home/gluex/gluex_top/cernlib;
setenv CERN_LEVEL 2005;
setenv CERNLIB_WORD_LENGTH 64-bit;
setenv XERCES_C_VERSION 3.1.1;
setenv XERCESCROOT /home/gluex/gluex_top/xerces-c/xerces-c-3.1.1;
setenv CLHEP_VERSION 2.0.4.5;
setenv CLHEP /home/gluex/gluex_top/clhep/2.0.4.5;
setenv ROOT_VERSION 5.34.26;
setenv ROOTSYS /home/gluex/gluex_top/root/root_5.34.26;
setenv CCDB_VERSION 1.05;
setenv CCDB_HOME /home/gluex/gluex_top/ccdb/ccdb_1.05;
setenv EVIO_VERSION 4.3.1;
setenv EVIOROOT /home/gluex/gluex_top/evio/evio-4.3.1/Linux-x86_64;
\end{verbatim}
\caption{Output of {\tt \$BUILD\_SCRIPTS/version.pl}.}\label{figure:version-pl-output}
\end{figure}
Since you would want these commands applied to the current shell level, in practice you use
\begin{verbatim}
       eval `$BUILD_SCRIPTS/version.pl version_1.7.xml`
\end{verbatim}
Following this step, one normally would invoke {\tt gluex\_env.(c)sh}
to complete the set-up of the environment.

In this example, the variable definitions come (mostly) in pairs, a
version variable and a home directory variable. The version variable
affects only the build process since the corresponding package
makefile keys off it (see
Section~\ref{section:package-makefiles}). The home directory variable
affects the build as well in that it tells the package makefile where
to find any prerequisite packages and in addition it affects use of a
build via its effect on path variables.

Finally, the script {\tt gluex\_env\_version.(c)sh} combines use of
{\tt version.pl} and {\tt gluex\_env.(c)sh} to more conveniently set
up the environment. We have already seen an example of its use in
Fig.~\ref{figure:version-script}. The script uses {\tt version.pl} as
shown above to set the stage for an invocation of {\tt
  gluex\_env.(c)sh}.

\subsection{Specifying Alternate Source Code Sources with a Version File}

We saw in Section~\ref{section:package-makefiles} that a URL variable
can be used to instructed the package makefiles to get the source code
from a version control repository rather downloading a tarball. The
{\tt url} attribute in the package element calls out the value of the
URL to use directly. In a particular {\tt package} element, either the
{\tt version} attribute or the {\tt url} attribute should
appear; if both appear then the {\tt version} attribute will
be used ({\it i.~e.}, tarball).
If the {\tt url} attribute is used, each package makefile
will interpret the URL as is appropriate for that package, either as a
Subversion repository or a Git repository; there can be only one
answer and it is coded into the package makefile. For Git
repositories, the optional {\tt branch} attribute controls which
branch is checked out. If it is absent, the master branch is
used. For example, to clone sim-recon and checkout the branch
{\tt test\_stuff}, use
\begin{verbatim}
     <package name="sim-recon"
              url="https://github.com/jeffersonlab/sim-recon"
              branch="test_stuff"/>
\end{verbatim}
Note that for Subversion repositories, the branch specification is
encoded in the URL itself and the branch attribute is ignored.

\subsection{Directory Tags}\label{section:directory-tags}

The {\tt dirtag} attribute can be used to distinguish different builds
of a package where the only difference between them is the version(s)
of one or more prerequisite packages. The string used is arbitrary. A
directory tag can be attached to either a source directory made from a
tarball or one from a source code repository. The tag name is appended
after a caret symbol (\^{}), for example,
\begin{verbatim}
  <package name="hdds" version="3.3" dirtag="xerces_test"\>
\end{verbatim}
in a version file would cause {\tt version.pl} to add an additional
variable to the environment:
\begin{verbatim}
  setenv HDDS_DIRTAG xerces_test
\end{verbatim}
and {\tt Makefile\_hdds} would then produce a directory named
{\tt hdds-3.3\^{}xerces\_test}, with source code obtained from the standard
tarball, {\tt hdds-3.3-src.tar.gz} in this case.

The corresponding home directory variable will also reflect the
directory tag, of course.

There are a lot possible meanings for the directory tag. It could mark
different combinations of prerequisites as well as designating
packages where the source code does {\bf not} come from a standard
source (tarball or repository). Because of the large number of
possibilities, the form of the tag string is left to the user; no
assumption is made about it meaning.

\subsection{Specifying Alternate Home Directory Locations}

Often one wants to use a build of a specific package that lies outside
of the standard directory structure. This can be put into the
environment by setting the {\tt home} attribute of the corresponding
{\tt package} element. For example
\begin{center} \tt
<package name="sim-recon" home="/home/my/sim-recon"/>
\end{center}
will cause {\tt version.pl} to generate
\begin{center} \tt
export HALLD\_HOME=/home/my/sim-recon
\end{center}
Note that this feature is mainly useful for creating an environment
for use; when building it (a) gives no guidance on where the source
code should come from and (b) does not cause the build to be done in
the named directory. It is useful when a pre-built package needs to be
referenced for the current task.

\section{The Prerequisites System}\label{section:prerequisites-system}

Each package may or may not have a build dependency on other packages
under the VMS. For example a particular version of sim-recon can be
built against any of a number of versions of HDDS, including custom
versions provided by the user. To insure that the environment being
set-up has a consistent set of package versions, a facility is
provided to warn the user if possible inconsistencies are detected.

At build time, a version xml file is created in the home directory of
a package if that package has dependencies on others in the
system. For example, \$HALLD\_HOME will have the file
sim-recon\_prereqs\_version.xml, listing the versions used to build
sim-recon. An example is shown in Fig.~\ref{figure:prereqs-xml-file}

\begin{figure}
\begin{verbatim}
                <gversion version="1.0"
                ><package name="evio" version="4.3.1"
                 /><package name="cernlib" version="2005"
                 /><package name="root" version="5.34.26"
                 /><package name="jana" version="0.7.3"
                 /><package name="hdds" version="3.3"
                 /><package name="ccdb" version="1.05"
                 /></gversion
                >
\end{verbatim}
\caption{An example of sim-recon\_prereqs\_version.xml.}\label{figure:prereqs-xml-file}
\end{figure}

At set-up time, when {\tt gluex\_env.(c)sh} is invoked, if a version
file with prerequisites is found in the package home directory, then
each package in that file is checked for version consistency. A match
is sought between the version number specified in the version file and
the version number encoded in the home directory for the prerequisite
package, {\it i.~e.}, the directory defined as home in the environment
being set-up. Here the version from the home directory is extracted in
two ways depending on how the package was built:
\begin{enumerate}
\item {\bf Tar File}. If the source code came from a tar file, then the version number is parsed out of the name of the home directory.
\item {\bf Subversion Checkout}. If the source was checked out of a subversion repository, the {\tt svn info} command is used to get the name of the subversion directory checked out and the version is parsed from that directory name.
\end{enumerate}
If a version mismatch is found, a warning is written to the screen.

\section{The gluex\_install System}

The {\tt gluex\_install} system uses {\tt build\_scripts} to create a
complete install of GlueX software from scratch. This is especially
useful for new machines.

No interaction from the user should be required to get a successful
build. The only assumption made is that the basic packages that come
in a minimal install are present. The definition of minimal
depends on the installation. In all cases, the distribution was tested
by first installing from a DVD or CD iso image. Typically, the ``live
DVD'' version was chosen since that installs the smallest number of
packages.

The scripts have been tested on the following distributions listed in
Table~\ref{table:tested-distributions}.

\begin{table}
$$
\begin{tabular}{|l|l|}
\hline
\bf Distribution & \bf Package Type \\
\hline
CentOS & RedHat \\
Scientific Linux & RedHat \\
Ubuntu & Debian \\
Fedora & RedHat \\
LinuxMint & Debian \\
openSUSE & RedHat \\
RedHat Enterprise & RedHat \\
\hline
\end{tabular}
$$
\caption{Gluex\_install tested distributions.}\label{table:tested-distributions}
\end{table}

\subsection{Installation Steps}

Root access is required for steps (1) and (2).

\begin{enumerate}

\item {\bf System Update}. It is recommended that you update your
  system to the latest versions of of all system supplied
  software. For RedHat-like distributions you do a ``yum update''. For
  Debian-like systems you do a ``apt-get update''.

\item {\bf Get the Scripts}. A tar file with these scripts is
  available at
\begin{verbatim}
  https://halldweb.jlab.org/dist/gluex_install.tar
\end{verbatim}
  You can also do a subversion check out of the latest version at
\begin{verbatim}
https://halldsvn.jlab.org/repos/trunk/scripts/gluex_install
\end{verbatim}
Note that most distributions do not have subversion in their minimal
set of packages.

\item {\bf Prerequisites: gluex\_prereq\_$<$distribution$>$.sh}. The
  prerequisites script installs packages from the distribution
  repository necessary for the GlueX build. As such, it must be
  executed by root. In addition it makes some symbolic links in system
  directories that are necessary for the cernlib build. These scripts
  are specific to particular distributions. You must run this
  script from inside the ``gluex\_install'' directory created when you
  get the scripts (see Get the Scripts, step 2).

\item {\bf Subversion test: svn\_touch.sh}. Simply does an ``l'' of the
  Hall D and 12 GeV subversion repositories at JLab, both as a test
  and to dispense with interactive prompts asking about certificates
  from the servers. Respond with ``p'', to permanently accept the
  certificates. These prompts would otherwise hang the build. If you
  are not prompted, you already recognize the certificates. The script
  is distribution independent.

\item {\bf Install: gluex\_install.sh}. Creates a directory,
  ``gluex\_top'', in the current working directory to house the build,
  sets up an environment, downloads all source files, and builds all
  libraries and executables needed to run GlueX software. The install
  assumes a directory structure that accommodates multiple versions of
  the GlueX packages if they are needed later. The script is
  distribution independent.

\end{enumerate}

\subsection{Using the Build}

After the build is complete, there are two files in the gluex
directory, setup.sh and setup.csh, that can be used to set-up the
complete GlueX environment under Bourne-like shells or C-like shells
respectively.

\end{document}

